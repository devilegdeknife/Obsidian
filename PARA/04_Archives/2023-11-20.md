---
创建时间: 2024-01-05
最后修改: 2026-02-15
状态:
  - Archives
tags:
  - #编程
  - #摄影
  - #生活技巧
  - #numpy
para: archives
aliases: []
---
# [[房贷]]
#生活技巧 
## 交房前断供
1. 贷款支付首付，借贷装修贷、信用贷款
   - 注意：贷款6期以上，法律规定还款不满6期容易定性为诈骗。
2. 转移支付
   - 已婚：转移给配偶或者父母；
   - 未婚：父母或者兄弟
3. 断供
   - 微信支付改绑父母或者亲朋好友

## 交房后断供
- 补充措施：房屋出租给朋友。等到银行拍卖，由于租约存在，银行会赔钱给朋友或者流拍，最后低价拿下全款房
  
# [[云服务器提供商服务]]
#编程
## 服务列表

| 类别 | 名称 | 作用结构 | 解释 |
|-|-|-|-|-|
| 分布式应用服务 | 企业级分布式应用服务 | 服务支持大规模分布式应用的开发和部署 | 提供企业级支持,使开发和部署大规模分布式应用变得更加容易 |
| 消息队列 | 消息队列MQ | 分布式消息队列系统,用于解耦和异步通信 | 允许不同组件之间通过发送和接收消息来解耦,提高系统可靠性和性能 |
| 微服务引擎 | 微服务引擎 | 支持构建、部署和管理微服务架构 | 帮助开发人员轻松创建、部署和管理微服务,提高系统的灵活性和可维护性 |
| 链路追踪 | 链路追踪 | 监测和跟踪分布式系统中服务之间的调用关系 | 用于分析和优化分布式系统中服务调用的性能和可靠性 |
| 应用高可用服务 | 应用高可用服务 | 提供应用级别的高可用性支持 | 确保应用在面临硬件或软件故障时仍然可用,提高系统稳定性 |
| 应用实时监控服务 | 应用实时监控服务 | 实时监测应用程序的性能和状态 | 通过收集和分析应用程序的数据,及时发现并解决性能问题 |
| Prometheus监控服务 | Prometheus监控服务 | 开源监控和警报工具,用于收集和处理系统的度量信息 | 用于监控系统的性能,发现潜在的问题,并触发警报 |
| 消息服务 | 消息服务 | 提供消息传递服务,支持异步通信 | 用于在不同组件之间发送和接收消息,实现异步通信,提高系统的松耦合性 |
| 消息队列Kafka版 | 消息队列Kafka版 | 基于Kafka的消息队列系统 | 提供高吞吐量、可持久化、分布式的消息队列服务 |
| 机器学习 | 机器学习 | 让计算机通过学习算法从数据中提取模式和知识 | 使计算机能够通过学习经验提高性能,广泛用于预测、分类和决策等领域 |
| 图像搜索 | 图像搜索 | 通过图像内容进行检索 | 允许用户使用图像作为查询条件,找到相关的图像或信息 |
| 智能推荐AlRec | 智能推荐AlRec | 提供个性化的推荐服务 | 利用算法分析用户行为和偏好,为用户推荐个性化的内容,提高用户体验 |
| 智能开放搜索OpenSearch | 智能开放搜索OpenSearch | 开源搜索和分析引擎 | 提供灵活的搜索和分析功能,适用于各种应用场景 |
| 云行情 | 云行情 | 提供云上的行情数据服务 | 为金融行业等提供实时的市场行情数据 |
| 数据总线 | 数据总线DataHub | 数据流转平台 | 用于支持数据在不同系统和组件之间的流转,实现数据共享和集成 |
| 检索分析服务 | 检索分析服务Elasticsearch版 | 基于Elasticsearch的检索和分析服务 | 用于构建实时的搜索和分析功能,支持全文搜索和复杂查询 |
| 图计算服务 | 图计算服务Graph Compute | 处理和分析图数据的计算服务 | 用于解决复杂的图结构数据分析和计算问题 |
| 实时计算Flink版 | 实时计算Flink版 | 基于Flink的实时计算服务 | 支持实时数据处理和分析,适用于大规模流式数据处理 |
| 智能数据建设与治理Dataphin | 智能数据建设与治理Dataphin | 数据治理平台 | 帮助组织管理和优化数据资产,确保数据的质量和合规性 |
| 开源大数据平台E-MapReduce | 开源大数据平台E-MapReduce | 大数据计算和存储平台 | 提供分布式计算和存储服务,支持大规模数据处理和分析 |
| 云原生大数据计算服务MaxCompute | 云原生大数据计算服务MaxCompute | 面向云原生的大数据计算服务 | 提供高性能、弹性的大数据计算和分析服务,适用于各种场景 |
| 实时数仓Hologres | 实时数仓Hologres | 实时数据仓库 | 提供实时的数据仓库服务,支持快速查询和分析实时数据 |
| 大数据开发治理平台DataWorks | 大数据开发治理平台DataWorks | 大数据开发和治理平台 | 支持大数据开发流程和数据治理,提高大数据应用的开发效率和数据质量 |
| 智能媒体服务 | 智能媒体服务 | 提供智能化的媒体处理和分析服务 | 用于处理和分析媒体内容,支持图像、音频和视频等多媒体数据 |
| 媒体处理 | 媒体处理 | 对媒体文件进行处理和编辑 | 包括图像、音频和视频等多媒体文件的处理和编辑功能 |
| 视频点播 | 视频点播 | 提供视频内容的按需播放服务 | 用户可以根据需要随时播放和观看视频内容 |
| 对象存储 | 对象存储 | 存储和检索大规模数据对象 | 用于存储和检索各种数据对象,如文件、图像和视频等 |
| 文件存储NAS | 文件存储NAS | 网络附加存储服务,支持多协议 | 提供网络附加存储,支持多个系统和协议,方便文件共享和访问 |
| 表格存储 | 表格存储 | 提供分布式的NoSQL表格存储服务 | 用于存储结构化数据,支持高并发和分布式访问 |
| 日志服务 | 日志服务 | 收集、存储和分析日志数据 | 用于管理和分析系统和应用产生的日志数据,帮助监测和故障排除 |
| 云存储网关 | 云存储网关 | 提供访问和管理云存储的网关服务 | 用于连接和管理云上存储服务,提供统一的访问接口 |
| 文件存储HDFS版 | 文件存储HDFS版 | 基于Hadoop分布式文件系统的文件存储服务 | 提供高可靠性、分布式的文件存储服务,适用于大规模数据存储和处理 |
| 块存储 | 块存储 | 提供块级别的存储服务 | 适用于虚拟机和容器等场景,提供高性能的块级别存储 |
| 混合云备份服务 | 混合云备份服务 | 提供混合云环境下的数据备份和恢复服务 | 支持在云上和本地之间进行数据备份和恢复,确保数据安全 |
| 密钥管理服务 | 密钥管理服务 | 提供安全的密钥管理和存储服务 | 用于管理和保护加密通信中使用的密钥,确保数据的机密性 |
| 云防火墙 | 云防火墙 | 提供云上的防火墙服务 | 用于保护云上资源免受网络攻击,实现网络安全 |
| 数据库审计 | 数据库审计 | 监测和记录数据库操作的审计服务 | 用于追踪和记录数据库的操作,确保数据库安全和合规性 |
| 加密服务 | 加密服务 | 提供数据加密和解密的服务 | 用于保护敏感数据的安全

# [[摄影指南]]
#摄影
## 普遍观点

1. 技术决定下限，审美决定上限。
2. 在数码摄影时代，通常情况下选择向右曝光。
3. 大部分情况下选择光圈优先档位，不要过于迷信手动档，因为在抓拍瞬间的时候，用手动档可能来不及。
4. 拍摄风光时，尝试将光圈值设定在F8-F11，以获得最佳画质和景深。根据实际情况调整。
5. 在拍摄星芒效果时，将光圈缩小至F8以下。
6. 多出去拍是提高摄影技术最好的途径。
7. 观看学习大师的作品是提高审美的最佳途径。
8. 摄影前期和后期同样重要。如果前期拍摄遇到瓶颈，尝试学习后期处理，形成全面的摄影技能。

## 曝光与参数

9. 我写向右曝光，并不等于过曝。理解摄影的人应该明白这个区别。
10. 在选择曝光时，避免过度曝光，因为弱进光量是引起噪点的主要原因。
11. 对于ISO，相机在1000左右的ISO下噪点不太明显。如果需要保持光圈不变，同时需要高速快门，可以适度提高ISO。
12. UV镜要么多花钱购买质量好的，要么就不要购买，因为质量较差的UV镜可能会影响画质。
13. 对于像素，绝大多数人使用2000w像素已经足够，但拍摄风光时更多像素有助于后期裁剪。

## 构图与创作

14. 不要死记各种构图法则，如三分法、黄金分割点法等。学会灵活运用，因为构图的目标是保持画面平衡并突出主题。
15. 在拍摄前优先制定计划，尤其是风光摄影。使用应用程序如谷歌地球，可以帮助节省大量时间。
16. 在一个新的拍摄地点，不要急于固定三脚架，而是先四处走动，观察构图再选择最佳机位。
17. 对于超广角镜头，要注意前景、中景和远景的运用，以创造更有深度的画面。
18. 在拍摄风光时，大光圈不是必需的，通常F2.8就足够。与其追求大光圈，不如考虑扩展焦段。
19. 在拍摄前尽量做好计划，尤其是风光摄影。学会灵活变通，利用天气、地形等因素获取最佳拍摄效果。

## 后期处理

20. 关于调色教程，如黑金色调、青橙对比等，要结合前期拍摄环境，避免强行运用。重点是学习思路，而不是死记参数设置。
21. 向右曝光的原因是弱进光量是引起噪点的主要原因。在后期调整亮度时，相比向左曝光更容易控制噪点。
22. 调色不是“无中生有”，而是在前期的基础上“锦上添花”。因此，掌握色彩原理和审美是影响调色效果的关键因素。

## 经验与心得

23. 摄影技术提高的最佳途径之一是多出去拍摄。实践是最好的老师。
24. 不要心疼购买摄影配件的费用。与其购买多余的配件，不如将资金用于旅行和实践，因为这才是真正提高技术的途径。
25. 刚开始使用相机时，先仔细阅读说明书，熟悉相机的使用方式。
26. 了解并尝试使用各种应用程序，如谷歌地球，提前规划拍摄地点，能够在拍摄时省时省力。
27. 在按下快门之前，要对所得照片有清晰的处理思路。不要按下快门之后再考虑后期处理。

# 优秀代码示例
#编程
## 1. 线性求逆元

cppCopy code

```cpp
for (int i = 2; i < MAXN; i++)
inv[i] = mul(inv[mod % i], mod - mod / i, mod);
```

这两行代码以惊人的简洁性实现了在$O(n)$时间内求解1到n对模m的逆元。

## 2. 求最大公因数


```cpp
int gcd(int x, int y) {     return y ? gcd(y, x % y) : x; }
```
这个求最大公因数的代码既简洁又优雅，第一次看到时让人产生疑问，但又让人陷入深思。

## 3. 树状数组

树状数组在单点修改和区间求和方面的高效实现：

**修改:**

```cpp
void add(int i, int x) 
{     
for (; i <= n; i += i & -i)         
tree[i] += x; 
}
```

**查询:**

```cpp
int sum(int i) {     
int ret = 0;     
for(; i; i -= i & -i)         
ret += tree[i];     
return ret; 
}
```

这种巧妙的实现令人一次次惊叹，深深印在记忆中。

## 4. zkw线段树

用于单点修改区间查询的zkw线段树：

**修改:**

```cpp
int query(int l,int r){
	int ret = 0;
	for (l += treeLen - 1, r += treeLen +1; l ^ r ^ 1; l >>= 1, r >>= 1){
		if (~l & 1)ret = min(ret, val[l^1]);
		if (r & 1)ret = min(ret, val[r ^ 1]);
	}
	return ret;
}
```

**查询:**

```cpp
int query(int l,int r){
	int ret = 0;
	for (l += treeLen - 1, r += treeLen +1; l ^ r ^ 1; l >>= 1, r >>= 1){
		if (~l & 1)ret = min(ret, val[l^1]);
		if (r & 1)ret = min(ret, val[r ^ 1]);
	}
	return ret;
}
```

# Numpy 图解教程
#编程 #numpy
为大家准备了一篇关于Numpy的图解教程。本文用可视化的方式介绍了 NumPy 的功能和使用示例。

![](https://pic4.zhimg.com/v2-07d24f607698ef96426983b189760c3b_r.jpg)

NumPy 软件包是 Python 生态系统中数据分析、机器学习和科学计算的主力军。它极大地简化了向量和矩阵的操作处理。Python 的一些主要软件包（如 scikit-learn、SciPy、pandas 和 tensorflow）都以 NumPy 作为其架构的基础部分。除了能对数值数据进行切片（slice）和切块（dice）之外，使用 NumPy 还能为处理和调试上述库中的高级实例带来极大便利。本文将介绍使用 NumPy 的一些主要方法，以及在将数据送入机器学习模型之前，它如何表示不同类型的数据（表格、图像、文本等）。

```text
import numpy as np
```

**创建数组**我们可以通过传递一个 python 列表并使用 np.array（）来创建 NumPy 数组（极大可能是多维数组）。在本例中，python 创建的数组如下图右所示：

![](https://pic3.zhimg.com/v2-bc4c81839c61849f1daa9c064834c0b6_r.jpg)

通常我们希望 NumPy 能初始化数组的值，为此 NumPy 提供了 ones()、zeros() 和 random.random() 等方法。我们只需传递希望 NumPy 生成的元素数量即可：

![](https://pic3.zhimg.com/v2-29694bf4180dfe8cb156442d7b672222_r.jpg)

一旦创建了数组，我们就可以尽情对它们进行操作。**数组运算**让我们创建两个 NumPy 数组来展示数组运算功能。我们将下图两个数组称为 data 和 ones：

![](https://pic2.zhimg.com/v2-1a7c7ec587b8cc20663000798fea40c1_r.jpg)

将它们按位置相加（即每行对应相加），直接输入 data + ones 即可：

![](https://pic2.zhimg.com/v2-d19d1c60a9858356dd0aa0a7607e51cd_r.jpg)

当我开始学习这些工具时，我发现这样的抽象让我不必在循环中编写类似计算。此类抽象可以使我在更高层面上思考问题。除了「加」，我们还可以进行如下操作：

![](https://pic2.zhimg.com/v2-87fd8396f9ae0d5facee85a935b163a5_r.jpg)

通常情况下，我们希望数组和单个数字之间也可以进行运算操作（即向量和标量之间的运算）。比如说，我们的数组表示以英里为单位的距离，我们希望将其单位转换为千米。只需输入 data * 1.6 即可：

![](https://pic2.zhimg.com/v2-5f2522fda06d61c7e001520a2c68d6c1_r.jpg)

看到 NumPy 是如何理解这个运算的了吗？这个概念叫做广播机制（broadcasting），它非常有用。**索引**我们可以我们像对 python 列表进行切片一样，对 NumPy 数组进行任意的索引和切片：

![](https://pic1.zhimg.com/v2-ed44d58c5676f066a784059f30810400_r.jpg)

**聚合**NumPy 还提供聚合功能：

![](https://pic4.zhimg.com/v2-de266ce9d88e87e6d1ddc3d1c5c274af_r.jpg)

除了 min、max 和 sum 之外，你还可以使用 mean 得到平均值，使用 prod 得到所有元素的乘积，使用 std 得到标准差等等。**更多维度**上述的例子都在一个维度上处理向量。NumPy 之美的关键在于，它能够将上述所有方法应用到任意数量的维度。**创建矩阵**我们可以传递下列形状的 python 列表，使 NumPy 创建一个矩阵来表示它：

```text
np.array([[1,2],[3,4]])
```

我们也可以使用上面提到的方法（ones()、zeros() 和 random.random()），只要写入一个描述我们创建的矩阵维数的元组即可：

![](https://pic2.zhimg.com/v2-4eaafeb9275715e358235ea6cdb3d825_r.jpg)

**矩阵运算**如果两个矩阵大小相同，我们可以使用算术运算符（+-*/）对矩阵进行加和乘。NumPy 将它们视为 position-wise 运算：

![](https://pic4.zhimg.com/v2-43c8a8b5cbea9509805d9499967fbe3b_r.jpg)

我们也可以对不同大小的两个矩阵执行此类算术运算，但前提是某一个维度为 1（如矩阵只有一列或一行），在这种情况下，NumPy 使用广播规则执行算术运算：**点乘**算术运算和矩阵运算的一个关键区别是矩阵乘法使用点乘。NumPy 为每个矩阵赋予 dot() 方法，我们可以用它与其他矩阵执行点乘操作：

![](https://pic1.zhimg.com/v2-79ad8638a53566974bd5a2333fae8cd0_r.jpg)

我在上图的右下角添加了矩阵维数，来强调这两个矩阵的临近边必须有相同的维数。你可以把上述运算视为：

![](https://pic1.zhimg.com/v2-71a17d45147c5bd3b0f7e8a0832cfd28_r.jpg)

**矩阵索引**当我们处理矩阵时，索引和切片操作变得更加有用：

![](https://pic4.zhimg.com/v2-5a03f13f75f37a34510fac256e14bb53_r.jpg)

**矩阵聚合**我们可以像聚合向量一样聚合矩阵：

![](https://pic3.zhimg.com/v2-cfd786a534fdbda150fd39fbb9e7848a_r.jpg)

我们不仅可以聚合矩阵中的所有值，还可以使用 axis 参数执行跨行或跨列聚合：

![](https://pic3.zhimg.com/v2-923eb56c78eed300552640c5eea5082a_r.jpg)

**转置和重塑**处理矩阵时的一个常见需求是旋转矩阵。当需要对两个矩阵执行点乘运算并对齐它们共享的维度时，通常需要进行转置。NumPy 数组有一个方便的方法 T 来求得矩阵转置：

![](https://pic4.zhimg.com/v2-5964d7ea2e0955a998b04cdbec401e07_r.jpg)

在更高级的实例中，你可能需要变换特定矩阵的维度。在机器学习应用中，经常会这样：某个模型对输入形状的要求与你的数据集不同。在这些情况下，NumPy 的 reshape() 方法就可以发挥作用了。只需将矩阵所需的新维度赋值给它即可。可以为维度赋值-1，NumPy 可以根据你的矩阵推断出正确的维度：

![](https://pic2.zhimg.com/v2-d317c75c992d9a7b2f4d751068fb7181_r.jpg)

**再多维度**NumPy 可以在任意维度实现上述提到的所有内容。其中心数据结构被叫作 ndarray（N 维数组）不是没道理的。

![](https://pic2.zhimg.com/v2-999112bfd7db5a5110be785d16224151_r.jpg)

在很多情况下，处理一个新的维度只需在 NumPy 函数的参数中添加一个逗号：

![](https://pic3.zhimg.com/v2-81dfeac5531c54f9a1d0ec0a38c15fca_r.jpg)

**实际用法**以下是 NumPy 可实现的有用功能的实例演示。**公式**实现可用于矩阵和向量的数学公式是 NumPy 的关键用例。这就是 NumPy 是 python 社区宠儿的原因。例如均方差公式，它是监督机器学习模型处理回归问题的核心：

![](https://pic1.zhimg.com/v2-21184944f2a379ccdd17786f6ed5da4c_r.jpg)

  

在 NumPy 中实现该公式很容易：

![](https://pic4.zhimg.com/v2-817eb643878c88a830ba1098c137cb47_r.jpg)

这样做的好处在于，NumPy 并不关心 predictions 和 labels 包含一个值还是一千个值（只要它们大小相同）。我们可以通过一个示例依次执行上面代码行中的四个操作：

![](https://pic4.zhimg.com/v2-58618d799da456a604eb533b7d16003f_r.jpg)

预测和标签向量都包含三个值，也就是说 n 的值为 3。减法后，得到的值如下：

![](https://pic3.zhimg.com/v2-dd39bd5fd0a49db822f79942c6f5fab6_r.jpg)

然后将向量平方得到：

![](https://pic4.zhimg.com/v2-6f57aae24d4e371edce6d400877461a3_r.jpg)

现在对这些值求和：

![](https://pic1.zhimg.com/v2-195c5b6f9fa0f43221357d5d99f32bc0_r.jpg)

得到的结果即为该预测的误差值和模型质量评分。**数据表示**考虑所有需要处理和构建模型所需的数据类型（电子表格、图像、音频等），其中很多都适合在 n 维数组中表示：**表格和电子表格**电子表格或值表是二维矩阵。电子表格中的每个工作表都可以是它自己的变量。python 中最流行的抽象是 pandas 数据帧，它实际上使用了 NumPy 并在其之上构建。

![](https://pic4.zhimg.com/v2-337024199f2afce3a4181505b63cdedb_r.jpg)

**音频和时间序列**音频文件是样本的一维数组。每个样本都是一个数字，代表音频信号的一小部分。CD 质量的音频每秒包含 44,100 个样本，每个样本是-65535 到 65536 之间的整数。这意味着如果你有一个 10 秒的 CD 质量 WAVE 文件，你可以将它加载到长度为 10 * 44,100 = 441,000 的 NumPy 数组中。如果想要提取音频的第一秒，只需将文件加载到 audio 的 NumPy 数组中，然后获取 audio[:44100]。以下是一段音频文件：

![](https://pic3.zhimg.com/v2-ec879431363b8a4883418edc86ead002_r.jpg)

时间序列数据也是如此（如股票价格随时间变化）。**图像**图像是尺寸（高度 x 宽度）的像素矩阵。如果图像是黑白（即灰度）的，则每个像素都可以用单个数字表示（通常在 0（黑色）和 255（白色）之间）。想要裁剪图像左上角 10 x 10 的像素吗？在 NumPy 写入即可。下图是一个图像文件的片段：

![](https://pic3.zhimg.com/v2-0350e49036ba36e985897a320f59e7d2_r.jpg)

如果图像是彩色的，则每个像素由三个数字表示——红色、绿色和蓝色。在这种情况下，我们需要一个三维数组（因为每个单元格只能包含一个数字）。因此彩色图像由尺寸为（高 x 宽 x3）的 ndarray 表示：

![](https://pic2.zhimg.com/v2-050f52eaee1ed55389a56fb07b600fed_r.jpg)

**语言**如果我们处理文本，情况就不同了。文本的数字表示需要一个构建词汇表的步骤（模型知道的唯一字清单）和嵌入步骤。让我们看看用数字表示以下文字的步骤：模型需要先查看大量文本，再用数字表示这位诗人的话语。我们可以让它处理一个小数据集，并用它来构建一个词汇表（71,290 个单词）：

![](https://pic3.zhimg.com/v2-335b637f567b63e99f2b2a4ac9076976_r.jpg)

这个句子可以被分成一个 token 数组（基于通用规则的单词或单词的一部分）：

![](https://pic4.zhimg.com/v2-fe38977cf77a69d65d799ca31a401a6f_r.jpg)

然后我们用词汇表中的 ID 替换每个单词：

![](https://pic1.zhimg.com/v2-fe0126a62fc93347ad2e89a35df183b0_r.jpg)

这些 ID 仍然没有为模型提供太多信息价值。因此，在将这一组单词输入到模型之前，我们需要用嵌入替换 token/单词（在本例中为 50 维 word2vec 嵌入）：

![](https://pic4.zhimg.com/v2-78423dfe6aab69b191ba113782fa8f2f_r.jpg)

可以看到，该 NumPy 数组的维度为 [embedding_dimension x sequence_length]。出于性能原因，深度学习模型倾向于保留批大小的第一维（因为如果并行训练多个示例，模型训练速度会加快）。在这种情况下，reshape() 变得非常有用。如像 BERT 这样的模型期望的输入形式是：[batch_size，sequence_length，embedding_size]。

![](https://pic3.zhimg.com/v2-1d11147e43722c1c20849846e47883ea_r.jpg)

现在这是 numeric volume 形式，模型可以处理并执行相应操作。其他行虽然留空，但是它们会被填充其他示例以供模型训练（或预测）。