---
创建时间: 2026-02-02
最后修改: 2026-02-15
状态:
  - Resource
tags: []
---
# 计算机的哪些学科是被建议在本科阶段学掉的？
[内容链接](https://www.zhihu.com/question/595969891/answer/2990248628)

：（建议按顺序学。的绕道）

- C（C生万物）

2. 离散数学

3. 数据结构与算法

4. 数字电路（数字逻辑）(掌握部分就可以，不用深入)

5. 计算机组成原理

6. 单片机（51 8051建议学汇编版本），不用深入，了解单片机怎么通过I/O控制多个外设

7. 操作系统（、（recommend，因为你可以做他的配套实验））

7. 编译原理

8. 计算机网络

9. 数据库

不建议花大把时间学Python或者其他语言，也不建议科班学生在大学把时间都花在学语言上面，学好C就足够。你应该花时间去掌握计算机科学的核心，这些才是computer science。可能对你没有工作经验的帮助，当然你也大可去卷算法岗，但是我认为作为一个计算机科学与技术的学生，底层一定要吃透：这是你未来年薪50w和别人年薪20的区别。如果本科阶段只学会了编程语言，那和熟练使用office没啥区别，特别是在当下的人工智能时代，只会普通的编程是注定走不长远的。你如果非常非常**，我推荐的道路并不适合你。

## 以上课程学完后，你就要根据自己的兴趣选择你更偏爱的方向了：

- 你可以选择走纯软件的方向，这是大多数人选择的路，选择非常广泛。

2. 显然你还可以走软硬件结合的方向，比如嵌入式软件，更甚者你还会接触嵌入式系统或者系统内核。

3. 你还可以抱着探索的欲望继续学下去，计算机图形学、密码学等等，你会发现计算机的世界非常之大，大到学习不同方向的两个计算机专业的学生很难听懂对方所做的工作，壁垒很高。

更新一波：可能网上会有某某机构出来月薪一两万的告诉你:

> 学重复造轮子没用，力扣刷多少题怎么怎么就行。

- 是，你大可以这么做，毕竟在这个功利的世界，钱才是第一位，也没有那么纯粹的热爱去为爱发电。
- 但是，当你吃透这些，即使你未来不从事cs相关的，也对你有很大的帮助。

**封装**，这是计算机中最核心的思想，无论是计算机中的硬件层和软件层，都依靠这个思想一层一层搭建，这也是计算机为何发展如此迅速的原因。

不知道初入大学的你，是否对计算机是怎么工作的比较好奇？

- 我大一的时候就特别好奇，所以开学第一天，我就跟我一个室友说道“我觉得计算机这个东西很神奇，听说计算机是01构成的，但是01怎么构成屏幕上的花花世界呢”

这个问题一直困扰着我，直到我把以上课程学习完…

有空更后续

- 大一上学完C语言，室友问我，这下你还觉得计算机神奇吗？我觉得还是很神奇，这么接近自然语言的东西编译运行后竟然可以做出逻辑如此复杂的操作，而且我还是不太懂计算机是怎么看懂C语言的？电路可以识别语言吗？计算机的内部对我还是一个黑箱…
- 当时深受室友影响，觉得离散数学没啥用，每节课都逃…
- 后来比学校安排的课程提前接触到了算法，起因是第一次在写编程题目时两个数比大小




最少比较两次，最多一共比较三次

诶，如果是四个或者更多呢？那我怎么比较？在网上搜到了冒泡

接下来便接触到各种排序算法…后面又接触链表堆栈树…

学到这时再对比离散数学的图论，豁然开朗，后悔当时没有好好学离散，又回头去恶补…

下课溜了…

- 4.20 1：34，来更新下一个阶段：
- - 大二上，学完模电->这什么玩意，跟计算机有什么关系，感觉只学懂三极管可以当个开关，二极管只能一个方向导通…垃圾中国大学什么水课
- 大二下，学数电-＞引入与门非门或门后，噢原来是这样来实现电路的逻辑控制的。了解了3-8译码器，哦！这样就可以只用3根线来控制8个设备。诶，这不是红石嘛…诶，但是与门非门或门这些原件内部是什么呢？拆开内部一看，哦跟上面连起来了，原来是模电学的三极管二极管等等。但是什么是0什么1呢？正电压是1负电压是0？不对。高电平是1低电平是0？不行，太笼统了，3.3V算高电平吗5V算高电平吗100V算高电平吗？总得有个严格定义吧。模电告诉你，TTL电路中，5V是高电平，CMOS电路中，3.3V是高电平。好，这下我总算知道计算机中0和1是什么了。但是这些0和1怎么构成计算机呢？数电告诉，通过与非门的排列组合组合，可以实现。怎么实现呢？接下来计算机组成原理会告诉你：how to build a computer with these unit
- 讲计算机组成原理，
- - 就不得不提当下计算机的两个体系结构：一个是冯诺依曼，另一个是哈佛。
- - 冯诺依曼结构：一种将程序指令存储器和数据存储器合并在一起的存储器结构。
- 哈佛结构：一种将程序指令存储和数据存储分开的存储器结构。
- 这俩名字都挺熟悉吧，你肯定了解，当代计算机基本上都采用了冯诺依曼结构，但是你是否好奇，指令和数据存放在一起，不乱吗…我也是这么想的，但是！后面操作系统会告诉你，不乱
- 至于哈佛结构，讲单片机那部分再说…
- 回到主线，计算机是由什么组成的？没学过的小伙伴肯定回答的不详细，但是这玩意呢，又叫电脑，既然跟“脑”有关，那首先得会加减法和逻辑吧，这就是算数逻辑单元：ALU：arithmetic logic unit
- 仅仅有ALU有用吗？肯定没有用，ALU不给人用那就是块垃圾…所以还得有个交互设备，键盘和显示器对吧，这就是输入输出设备：IO：in/out
- 好了，现在我的电脑基本上可以运行了，键盘输入，ALU计算，显示器输出。诶，等等，这玩意不是计算器嘛…
- 是的，他还不配被叫做计算机，这两者的主要区别就在于：计算机可以自动执行不止一条指令——如果每执行一条指令都要我动手输入一次那这玩意能提高生产力吗？
- 所以我们得有个东西保存指令，于是存储器：memory诞生了。我们可以一次性把大量指令写入存储器，让ALU去执行。
- 但是ALU怎么知道该从那条指令开始执行呢？我们还需要一个控制器，其中一个PC：指令控制器，一般上电后都清0，指向第一条指令，每执行完一条指令，PC自动➕1。这样我们一个自动的执行指令的计算机就构造完成了。控制器和ALU合起来，再加上一些寄存器，就构成了我们熟知的CPU了。
- 另外一个问题是，我们的memory掉电，所有的数据就消失了，和生活一联想，我们可以使用持久化的存储器，来保存数据，使用内存来运行程序呀。这不一下贯通了嘛。到了这里，计算机还神奇吗？还是很神奇，现在还有几个问题没有解决：

- 这样的计算机只能执行一个程序，但现代计算机可是能同时跑好几个程序：我玩LOL挂着QQ微信听着QQ音乐，死了就切出去看看消息…这么多程序，显然我的这台计算机做不到

2. 我的C语言程序是怎么转换成指令的？

3. 网络呢？没有网的计算机拿来玩蜘蛛纸牌吗

睡觉，后续随缘……

2023.4.28 3:18

今天遇到一个从三年级开始接触代码的女生，反正就是，把我震惊到…她现在16岁，无论是英语能力还是对底层的掌握又或是算法的掌握，远远高于我…好了，我是废物大学生

当然，她现在因为一些原因没有读书了，但是我相信以她的天赋和学习能力，真要高考top2不是问题…

又是一个不眠之夜

ok 时隔一年，再来更新一次。

- 上面的第一个问题：我的计算机只能执行一个程序，但一旦我想要执行第二个程序，或者两个程序同时执行，我应该怎么做？
- 你或许会回答，简单，只需要使用两个CPU就可以了，第一个CPU执行第一个程序，第二个CPU执行第二个程序，这就解决了。回答是正确的，我们的确可以这样做。但如果有第三个程序呢？如果有第四个程序呢...你不可能无限制得叠加CPU吧。
- 现在我们考虑一个软件，这个软件很特别，他可以让多个程序在这一个程序上执行。

我们看下面一个例子：

既然我们提到，多个程序可以在一个程序上面执行，那就应该是这样吧？但是根据c语言语法，这里定义了两个变量都是a，那肯定是错的，编译都过不了。

聪明如你肯定想到了，可以用函数，比如这样：

很好，但是现在我们有两个问题，第一个：main函数里先调用了process1和process2，那如果我要运行process2和process1，那我是不是需要修改源代码？第二个问题：C语言基础稍微好一点的同学能发现，这段代码生成的其实是一个可执行程序，也就是函数调用其实并不是我们想要的切换程序。

前面我们讲到，一个程序，其实只能被CPU执行，也就是说我们想要的这个特别的软件，他要实现多个程序在这个程序上面执行，他应该是通过控制CPU的寄存器来实现的，而不是函数调用。

所以我们应该做如下的修改：

这就是一个非常非常小的特别软件他可以切换程序，通过分时复用这个概念在一段小的时间内切换一个程序执行，而这个过程对于用户程序来说是透明的，用户程序只会认为自己一直在占用CPU。但是这只是包含了如何切换一个程序，而实际上的操作系统的这个过程非常非常复杂，在linux中，还包含了、，你需要了解系统是如何在内核态和用户态之间切换的。

既然讲到了内核态和用户态，我们就来讲一下他们是什么吧。

先讲是什么，再讲为什么。

- 内核态：顾名思义，内核程序被CPU执行时的运行状态，能执行的指令更多，比如特权指令
- 用户态：顾名思义，用户程序被CPU执行时的运行状态，只能执行非特权指令

- 那为什么我们要把用户程序和内核程序给予不同的操作权限呢？很简单，我们不信任每一个用户程序。虽然我们不能以恶意揣测别人，但是也要防止一个木马程序想非法篡改或者读取别的程序的信息。因此我们赋予了操作系统内核更高的权限，让他可以和外设进行通信，也可以提供一个接口（syscall）给用户程序使用，这样我们就在一定程度上隔离了内核和用户程序。

2. 但是操作系统发展到了今天，特别是像linux这样的宏内核，因为他的驱动和内核是一起编译的，其源代码量是相当大的，一个人究其一生也无法读完所有源代码（换句话说，有屎山），我们很难保证这样的一个操作系统和他的驱动是没有安全漏洞。由于linux生态已经非常成熟了，不易于重构，而为了进一步保证安全，ARM架构又分开了一层：TEE（trusted execute environment）和REE(rich execute environment)，我们把linux代码运行在REE侧的内核态，而又在TEE侧运行另一个更加值得信任的内核，这样我们可以把加密解密签名验签等安全操作放在TEE侧执行，进一步确保了安全性。这被大量应用在一个需要安全的场景。

3. 后续后续，如果你还想进一步了解，

- 多线程：比如两个CPU一起跑一个程序、
- 互斥

- 内存管理:
- - 好奇malloc()如何分配一块内存吗？
- 好奇malloc()从内存/RAM的哪一个位置分配的一块内存吗？--相关:.heap
- 好奇程序调用函数的时候怎么进栈入栈的吗？递归调用的极限深度在哪里？--相关:.stack
- 为什么C语言定义一个数组int a[n]是错误的？为什么[]里不能是一个变量？--相关: .data
- int a[2][1024]和int a[1024][2]哪一个在程序中被使用，会导致程序执行速度变慢？--相关:page,TLB
- static修饰一个局部变量的真正含义是什么？--相关: .data
- 为什么我们说一个良好的编程习惯，是给每个变量定义后，都赋予一个初始值？--相关: .bss
- 为什么部分编译器只支持int main()而不是void main()? --相关:exit(),_main(),signal
- int *ptr1 和int **ptr2有区别吗?char str1[]="hello world"和 char *str2 = "hello world"有什么区别？--试试printf("%p %p",str1, &str1) 和 printf("%p %p",str2, &str2)看看有什么区别。

如果有如下函数,试试在test(str1,str1)和test(str2,str2)中打印相关地址，看看区别。

下面回复一个回答：

> 高赞那个我是真的不赞同，我看一半就肯定这一定没上过班，感觉好像这还是个学生，后面果然是个大学生，太脱离现实了。。。因为讲的太底层了。。。属于一般码农一辈子都用不上的，而且属于底层到硬件了，建议去转EE，或者自动化，搞硬件相关的可以多看看

首先，我在最前面已经说了这是推荐给的学生的，而不是软件工程；其次，我也说了

> 你大可以这么做，毕竟在这个功利的世界，钱才是第一位，也没有那么纯粹的热爱去为爱发电

再一个我并不是推荐给码农的，我是推荐给一个想要学好cs的大学生的，再一个裁员，那也是裁员的低端码农，而且社会上不缺这样的码农，coding对于一个cs的学生很难吗？但一个经验丰富底层牢固的系统架构师，越老越吃香。一个工具谁都可以用，的

另外国内外还有很多厂商做交换机或者路由器的，是需要这样的底层开发人员的，你这一句话直接把这类人抹杀了。他们需要掌握的可不只是底层的知识，还要有计算机网络和算法的知识，这和你所说的自动化区别很多。前面说的电路数字逻辑等，不是让你学硬件，而是让你了解硬件，以及如何编写软件控制硬件。

对于我个人，我不喜欢一切封装过深的语言比如java go rust python，我只会把他们当做一个工具使用。

当然，这些都是计算机中基础中的，细分下来每一个方向都够我们普通人去研究很久了，萝卜青菜各有所爱，我也只是**推荐**。

今天才发现知乎竟然可以使用markdown。我修改一下之前的内容格式..
