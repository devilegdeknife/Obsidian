---
type: resource
source: zhihu
url: https://www.zhihu.com/question/373818321/answer/1960860274119669035
topics: [AI, 机器学习, 模型训练, 编程, C++, 工程]
status: processed
para: resource
tags: []
created: 2026-02-02
updated: 2026-02-11
---
# 为什么现在很多高端主板还保留PS/ 2键鼠接口？
[内容链接](https://www.zhihu.com/question/373818321/answer/1960860274119669035)

受不了一些打着辟谣的旗号在那瞎扯。

反过来想一下，如果PS/2口如此费拉不堪，为什么主板厂商还要在主板上集成这么一个占地方的玩意？**毕竟主板厂商连几毛钱的电容成本都要斤斤计较的**。几十年来，主板上出现又消失的接口包括串口、并口、VGA口、DVI口……但是PS/2口几乎一直存活到现在，真当厂商是傻子？

很多对硬件半懂不懂的人会说USB比PS/2快，咱们抛开PS/2的稳定性和抗干扰不谈，就来算算到底哪个快：

**PS/2的最大带宽是10Kbps~16Kbps之间**

**USB2.0是480Mbps**

两者看上去有数量级上的差距，USB速度比PS/2快的多，但是实际真不是这么算的。

先说PS/2，PS/2的口上跑的是串口协议，有启停位、校验位这些，所以PS/2的理论带宽大概不到1KB/s，每个包都要扣除几个bit的占位信息。

> Data signal: Serial data at 10.0–16.7 kHz with 1 start bit, 8 data bits (LSB first), 1 parity bit (odd), 1 stop bit, [1 ack bit (if host-to-device)]

再看USB，USB就复杂的多了，首先：USB键盘用的是interrupt传输，**中断传输并不能利用全部的480Mbps**，并且虽然USB口是2.0，但很多USB键盘的厂商会抠门的使用1.1的设备，**USB 1.1的中断传输每秒最大频率只有1KHz**，USB HID report的包长度是8个字节：

![图片描述](https://picx.zhimg.com/v2-fa7787f2e5d572a0f9f58f10bc700e9e_r.jpg?source=2c26e567)

所以USB键盘的最大带宽是8KB/s，虽然USB中断传输的最大包长能达到64（fullspeed）~1024（highspeed），但是HID只用了8字节。

看上去8K对比1K，USB还是比PS/2要快8倍，但是USB有一个问题：不管你按下一个键，还是按下6个键，都要占用整个HID report，也就是说，这8KB的带宽不管按多还是少，都一样。如果每个报文只报告一个键码，那么**USB HID的实际带宽就只剩下1KB/s了，这个PS/2的最大带宽基本上差不多**。

所以，**第一个结论：一次只按下一个按键的情况下，USB键盘和PS/2键盘没有太大的性能差异**。

写到这里，一定会有大聪明来站出来说：**你上面说的不对，PS/2的轮询速度只有100Hz，USB是125 Hz，还是USB更快**，并且很有可能会附上维基百科上的一段话：

> USB mice send data more quickly than PS/2 mice because standard USB mice are polled at a default rate of 125 Hz while standard PS/2 mice send interrupts at a default rate of 100 Hz when they have data to send to the computer.

但是，仔细看：这玩意**说的是鼠标，不是键盘**，因为鼠标要报告位移的状态，采样率太低会显得很卡顿，太高的话鼠标硬件本身性能不足（十几块钱的东西性能好不到哪去），操作系统也需要更多的软件资源处理。所以，很多人提到的PS/2的性能问题，对比的都是键盘，不是鼠标，**因为PS/2的鼠标确实比USB的要慢**。

继续看键盘的性能差异，USB键盘的最大问题是，USB键盘的读取动作是由主机的软件**主动发起的**，不要被USB interrupt传输这个名字给欺骗了，它叫中断传输没错，但是**它不是中断**，它是实打实的由主机发起，硬件响应，硬件返回数据，这种半双工的模式的通信访问，请求是纯软件实现的，需要一个操作系统的守护任务（进程、线程、回调函数等）在软件层面上主动轮询。

软件层面主动轮询就有一个问题：**桌面操作系统都不是实时系统，守护任务优先级再高也不能保证系统在高负载下保证轮询请求一定按时送出**，那么键盘的响应速度就永远得不到保证，并且如果CPU此时被关闭调度，或者驱动资源被锁住的情况下（USB控制器可能被别的任务发送URB导致资源不能释放），延迟可能是毫秒到十几毫秒之间——这已经是很大的延迟了。

而PS/2走的是真真正正的硬件CPU中断，**CPU中断在任何操作系统里都有着最高的调度优先级**，除非有人关闭了所有外部中断（USB传输本身也用外中断，关了以后USB传输损失更大）。所以PS/2键盘的键码报告速度几乎等同于硬件的速度，有延迟也是微秒级，不会出现软件层面上那种毫秒级的延迟。

所以USB键盘的延迟可能会很大，甚至可能会丢按键，但是PS/2键盘一定会把键码送到操作系统那边，进入键盘驱动的按键缓冲区里。

USB键盘驱动的软件逻辑：

PS/2键盘驱动的软件逻辑：

PS/2不需要主动发起什么请求，也不需要加什么锁，比USB要简单的多。

所以，**第二个结论：玩游戏说USB键盘不如PS/2键盘，这种说法是有道理的，USB键盘的软件响应速度是不确定的**。

那么USB键盘就真的打不过PS/2吗？也不是，USB协议很复杂。比如：USB协议也没有规定键盘一定要走HID，只不过HID是一个公共的规范，操作系统都默认支持，USB键盘使用额外的驱动，如果改用bulk传输，想怎么玩就怎么玩，速度吊打PS/2。

不过另外一个主流的思路是：把自己模拟成两个键盘，虽然一个键盘只能上报6个键码，但是两个键盘就是12个，这样就可以全键无冲了（除非你长了13个手指头），我电脑上的这个键盘就是：

![图片描述](https://pic1.zhimg.com/50/v2-b0ab5ab69ca952975675fe43e20be379_720w.jpg?source=2c26e567)

USB interface描述符里有两个：

但是，这要加钱。

高端主板既然要高端，那么PS/2这几块钱的接口还是要提供给用户的。

至于USB容易被干扰，早期操作系统对USB3.0适配不好，BIOS支持不好之类的问题，就不展开说了。

注意啊，评论区还有人说USB总线直通CPU，比PS/2快。有这种说法的，还是没理解USB协议的问题：**USB polling用的是软件，跟你硬件速度没关系**。

USB interrupt传输的polling的上限是1kHz，对应单按键带宽是1KB/s，这是建立在你的USB软件层面上没有任何延迟的情况下。

问题就在于，软件层面上保证不了没延迟，别说1ms的等待（对应1kHz），5ms的等待也做不到：

[C/C++中如何稳定地每隔5ms执行某个函数？](https://www.zhihu.com/question/536739862)

别说什么USB驱动工作在内核之类的话了，内核代码也不会让驱动占用全部CPU。

Windows虽然源码泄露过，但是Windows的代码还是不好直接放出来，贴一下Linux的代码：

Linux USB键盘处理的流程位于usbkbd.c:

[https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/hid/usbhid/usbkbd.c?h=v6.16.12#n100](https://link.zhihu.com/?target=https%3A//git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/hid/usbhid/usbkbd.c%3Fh%3Dv6.16.12%23n100)

处理的核心函数是：

前面处理键码是不怎么消耗CPU的，也是接近无锁的操作，问题出在usb_submit_urb这个函数上。

submit urb就是提交USB请求，这个请求下发到USB控制器的操作流程是：

对于EHCI来说，往下走的是

真正的延迟出现在这里，有两点：

1. 申请QTD是有锁的，一大堆锁；|
2. intr_submit也是有锁的，这还是一把大锁spin_lock_irqsave(&ehci->lock, flags)，锁整个EHCI

这意味着，如果系统负载很高，或者有任务长期占用EHCI的锁，那么键盘的submit urb就要等了，等到啥时候就看调度器了。

Windows也是一样，其实Windows性能优化做的更差，代码就不贴了。

PS/2键盘走的是8042中断控制器的代码，代码逻辑极其简单：

[https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/input/serio/i8042.c?h=v6.16.12#n556](https://link.zhihu.com/?target=https%3A//git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/input/serio/i8042.c%3Fh%3Dv6.16.12%23n556)

里面只有一把irq的锁，并且8042收到数据处理完了就完了，不需要像USB那样还要再次提交一个新的urb上去。

所以软件层面上哪个更快一目了然。硬件再快，软件响应不过来，该丢一样丢。别看USB总线速度都上G了，但是USB本质上还是一个由主机主动发起的协议，这就意味着它在性能上一直要依赖CPU（软件）。

参考文献：

[https://oe7twj.at/images/6/6a/PS2_Keyboard.pdf](https://link.zhihu.com/?target=https%3A//oe7twj.at/images/6/6a/PS2_Keyboard.pdf)

[https://www.stanislavs.org/helppc/8042.html](https://link.zhihu.com/?target=https%3A//www.stanislavs.org/helppc/8042.html)

[https://www.usb.org/sites/default/files/hid1_11.pdf](https://link.zhihu.com/?target=https%3A//www.usb.org/sites/default/files/hid1_11.pdf)

[https://www.usb.org/document-library/usb-20-specification](https://link.zhihu.com/?target=https%3A//www.usb.org/document-library/usb-20-specification)
