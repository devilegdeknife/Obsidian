---
type: resource
source: zhihu
url: https://www.zhihu.com/question/37692782/answer/2929878510
topics: [编程, C-C++, 技巧, 软件工程, 实践, 入门]
status: processed
para: resource
tags: []
created: 2026-02-02
updated: 2026-02-11
---
# 你见过哪些令你瞠目结舌的C/C++代码技巧？
[内容链接](https://www.zhihu.com/question/37692782/answer/2929878510)

Linux内核可谓是集C语言大成者，从中我们可以学到非常多的技巧，本文来学习一下宏技巧，文章有点长，但耐心看完后C语言level直接飙升。

**参考资料：**

[从Linux内核中学习高级C语言宏技巧](https://link.zhihu.com/?target=https%3A//mp.weixin.qq.com/s%3F__biz%3DMzkxNDQzMTI5MQ%3D%3D%26mid%3D2247484236%26idx%3D1%26sn%3D934faa85463577ce89488428d7f9376b%26chksm%3Dc16fcf18f618460e3cdae3ed8e884ceb205b8c81cf1504bf2fb12a391b5c96c0e5174338c6c7%23rd)

![图片描述](https://pica.zhimg.com/v2-2f8416286e7260dbbb8e0cc1b0b253c1_r.jpg?source=2c26e567)

## 1.用do{}while(0)把宏包起来

Linux中常见如上定义宏的形式，我们都知道do{}while(0)只执行一次，**那么这个有什么意义呢？**我们写一个更简单的宏，来看看

则在这样的语句中：

被展开为

fun2(x)将不会执行！有同学会想，加个花括号

则在这样的语句中

被展开为

注意}后还有个;这将会**出现语法错误**。

但是假如我们写成

则完美避免上述问题！

## 2.获取数组元素个数

写一个获取数组中元素个数的宏怎么写？显然用sizeof

**可以用，但这样是存在问题的**，先看个例子

输出：

为什么？**因为数组名和指针不是完全一样的，函数参数中的数组名在函数内部会降为指针！**

**sizeof(a),在函数中实际上变成了sizeof(int *)。**上面的宏存在的问题也就清楚了**，这是一个非常重大，且容易忽略的bug！**

让我们看看，内核中怎么写：

sizeof(arr) / sizeof((arr)[0]很好理解数组大小除去元素类型大小即是元素个数，真正的精髓在于后面__must_be_array(arr)宏

先看内部的__same_type，它也是个宏

__builtin_types_compatible_p 是gcc内联函数，在内核源码中找不到定义也无需包含头文件，在代码中也可以直接使用这个函数。（只要是用gcc编译器来编译即可使用，**不用管这个，**只需知道：

当 a 和 b 是同一种数据类型时，此函数返回 1。

当 a 和 b 是不同的数据类型时，此函数返回 0。

再看外部的（**精髓来了**）

**上来就是个小技巧：**!!(e)是将e转换为0或1，加个-号即将e转换为0或-1。

再用到了位域：有些信息在存储时，并不需要占用一个完整的字节， 而只需占几个或一个二进制位。例如在存放一个开关量时，只有0和1 两种状态，用一位二进位即可。这时候可以用位域

a占用3位，b占用3位，如上结构体只占用2字节，位域可以为无位域名，这时它只用来作填充或调整位置，不能使用，如：

当位数为负数时编译无法通过！当a为数组时，__same_type((a), &(a)[0])，&(a)[0]是个指针，两者类型不同，返回0，即e为0，-!!(e)为0，sizeof(struct { int:0; })为0，编译通过且不影响最终值。当a为指针时，__same_type((a), &(a)[0])，两者类型相同，返回1，即e为1，-!!(e)为-1，无法编译。

## 3.求两个数中最大值的宏MAX

思考这个问题，你会怎么写

## 3.1一般的同学：

存在问题，例子如下：

输出：

明显不对，因为>运算符优先级大于&，所以会先进行比较再进行按位与。

## 3.2稍好的同学：

存在问题，例子如下：

输出：

同样是优先级问题+优先级大于>。

## 3.3良好的同学

避免了前两个出现的问题，但同样还有问题存在：

期望结果：

实际结果

尽管用括号避免了优先级问题，但这个例子中的j++实际上运行了两次。

## 3.4Linux内核中的写法

下面进行详解。

**3.4.1.GNU C中的语句表达式**

**表达式**就是由一系列操作符和操作数构成的式子。 例如三面三个表达式

表达式加上一个分号就构成了**语句**，例如，下面三条语句：

A compound statement enclosed in parentheses may appear as an expression in GNU C.

——《Using the GNU Compiler Collection》6.1 Statements and Declarations in ExpressionsGNU C允许在表达式中有复合语句,称为**语句表达式：**

语句表达式内部可以有局部变量，语句表达式的值为内部最后一个表达式的值。

例子：

输出：y = 7。这个扩展使得宏构造更加安全可靠，我们可以写出这样的程序：

但这个宏还有个缺点，只能比较int型变量，改进一下：

但这需要传入type，还不够好。

**3.4.2 typeof关键字**

GNU C 扩展了一个关键字 typeof，用来获取一个变量或表达式的类型。

例子：

于是就有了

**3.4.3真正的精髓**

对比一下，内核的写法：

发现比我们的还多了一句

这才是真正的精髓，对于不同类型的指针比较，编译器会给一个警告：

提示两种数据类型不同。至于加void是因为当两个值比较，比较的结果没有用到，有些编译器可能会给出一个警告，加(void)后，就可以消除这个警告。

## 4.通过成员获取结构体地址的宏container_of

## 4.1作用

我们传给某个函数的参数是某个结构体的成员，但是在函数中要用到此结构体的其它成员变量，这时就需要使用这个宏：container_of(ptr, type, member)ptr为已知结构体成员的指针，type为结构体名字，member为已知成员名字，例子：

输出：s_a.b=8。本例子中通过struct_a结构体中的a成员地址获取到了结构体地址，进而对结构体中的另一成员b进行了赋值。

## 4.2详解

首先来看：

这个是获取在结构体TYPE中，MEMBER成员的偏移位置。

定义一个结构体变量时，编译器会按照结构体中各个成员的顺序，在内存中分配一片连续的空间来存储。例子：

输出

结构体的地址也就是第一个成员的地址，每一个成员的地址可以看作是对首地址的**偏移**，上面例子中，a就是首地址偏移0，b就是首地址偏移4字节，c就是首地址偏移8字节。

我们知道C语言中指针的内容其实就是地址，我们也可以把某个地址强制转换为某种类型的指针，(TYPE *)0)即将地址0，通过强制类型转换，转换为一个指向结构体类型为 TYPE的常量指针。

&((TYPE *)0)->MEMBER自然就是MEMBER成员对首地址的偏移量了。而(size_t)是内核定义的数据类型，在32位机上就是unsigned int，64位就是unsiged long int，就是强制转换为无符号整型数。再来看：

第一句（其实这句才是精华）

typeof在前面讲过了，获取类型，这句作用是利用赋值来确保你传入的ptr指针和member成员是同一类型，不然就会出现警告。

第二句

有了前面的讲解，应该就很容易理解了，成员的地址减去偏移不就是首地址吗，为什么要加个(char *)强制类型转换？

因为offsetof(type, member)的结果是偏移的字节数，而指针运算，（char *）-1是减去一个字节，（int *）-1就是减去四个字节了。最外面的 (type *)，即把这个值强制转换为结构体指针。

## 5.#与变参宏

## 5.1#和##

**#运算符**，可以把宏参数转换为字符串，例子

输出：

**##运算符**,可以把两个参数组合成一个。例子：

该程序的输出如下：

## 5.2变参宏

我们都知道printf接受可变参数，C99后宏定义也可以使用可变参数。C99 标准新增加的一个 __VA_ARGS__ 预定义标识符来表示变参列表，例子：

但是这个在使用时，可能还有点问题比如这种写法：

展开后

多了个逗号，编译无法通过，这时，只要在标识符__VA_ARGS__前面加上宏连接符##，当变参列表非空时，##的作用是连接fmt，和变参列表宏正常使用；当变参列表为空时，##会将固定参数fmt后面的逗号删除掉，这样宏也就可以正常使用了，即改成这样：

除了这些，其实Linux内核中还有很多宏和函数写得非常精妙。Linux内核越看越有味道，看内核源码，很多时候都会不明所以，但看明白后又醍醐灌顶，又感慨人外有人！

**本文出自：大叔的嵌入式小站**一个简单的嵌入式/单片机学习、交流小站

[从Linux内核中学习高级C语言宏技巧](https://link.zhihu.com/?target=https%3A//mp.weixin.qq.com/s%3F__biz%3DMzkxNDQzMTI5MQ%3D%3D%26mid%3D2247484236%26idx%3D1%26sn%3D934faa85463577ce89488428d7f9376b%26chksm%3Dc16fcf18f618460e3cdae3ed8e884ceb205b8c81cf1504bf2fb12a391b5c96c0e5174338c6c7%23rd)