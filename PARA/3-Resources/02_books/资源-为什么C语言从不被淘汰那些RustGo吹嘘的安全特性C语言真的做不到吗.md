---
创建时间: 2026-02-02
最后修改: 2026-02-15
状态:
  - Resource
tags: []
para: resource
aliases:
  - "为什么C语言从不被淘汰那些RustGo吹嘘的安全特性C语言真的做不到吗_0256"
---
# 为什么C语言从不被淘汰？那些Rust/Go吹嘘的安全特性，C语言真的做不到吗?
[内容链接](https://www.zhihu.com/question/13684481248/answer/113667434664)

因为工程或者市场上的成功，从来不代表工具本身需要精妙优秀啊……

C是ken自己趁老婆回娘家时候搞的的个人项目，第一版unix只有4000行不到，放今天的眼光看完全就只是个人自己玩的脚本，说是糊弄出来的也不为过，你要是自己写这种小工具，肯定也不会去遵守抽象规范，而是想到什么就写什么，当然Ken和Dennis这样的大牛也一样……

所以为了编译器简单，加上参与者就他自己和Dennis，很多东西本身就不需要通过语法约束而是两个人随口对一下某个变量是什么就可以，所以个人项目+没有协作者，直接就放飞自我了……

**【这点在go上也出现了，ken作为go的设计者之一，go许多被人诟病的语法都是由于“为了方便写编译器”这个原因导致的，未尝不是几十年后ken又整出来的烂活……以至于less is more这套理论在知乎上被许多人嘲笑成“我do less，你们就得do more”或者“大道智减”】**

甚至你可以理解成C语言诞生的时候压根没有一个东西叫做【设计过的C语言语法】，而是两个作者想到什么就写什么，而自己写出来什么，自然就是语法，先有程序，后补规则，《[C程序设计语言](https://link.zhihu.com/?target=https%3A//zh.wikipedia.org/wiki/C%25E7%25A8%258B%25E5%25BA%258F%25E8%25AE%25BE%25E8%25AE%25A1%25E8%25AF%25AD%25E8%25A8%2580_%28%25E4%25B9%25A6%29)》这本身书甚至是C语言诞生好多年以后才补上的

所以70到80年代的蛮荒时代，长一段时间“没人知道C到底有哪些语法”，而是编译器开发者们爱怎么自由发挥就能怎么自由发挥，编译器就是C的规范，那个年代孱弱的硬件性能导致编译器本身也不像今天可以整出各种复杂的优化，自然是最下里巴人平铺直叙的语言写编译器最容易，程序复杂度也有限，完全可以把约束交给程序的脑子完成

C还有个爸爸叫B，B还有个爸爸叫A

A就是典型的约束严格的学术派语言，而A->B->C这个发展脉络，就是“约束太严格写起来不爽，反正编译器也只是从源代码翻译成汇编，干嘛不把语言设计得约束更少一点，让程序员少了解一点数学原理**（再次强调，那个年代由于硬件性能孱弱，编译器不是今天的复杂工业软件，而是谁都可以手搓，语法上越简陋越好搓）**”。

至于上古时代的C编译器有多简陋……[legacy-cc/prestruct at master · mortdeus/legacy-cc](https://link.zhihu.com/?target=https%3A//github.com/mortdeus/legacy-cc/tree/master/prestruct)可以看看这个……几乎不比大学生的编译原理作业复杂多少，优化基本是没有的，写什么就是什么

在上古时代计算机硬件还不算很复杂的情况下这当然是一种“和汇编一一对应的语言”

可是问题是，今天的汇编都算不上贴近硬件了，随便一个家用X86的计算机，你哪怕徒手写的汇编都不代表执行顺序和你写的一一对应，你代码上心心念念的“内存布局”和硬件层面真正的内存布局八竿子打不着（对，80 90年代尚且可以认为内存在硬件层面上是线性布局，但是今天内存的硬件结构至少做了6到7层抽象）你代码语义层面写的一个struct一段内存，仅仅只是在汇编层面假装成一段，真实的物理上可能每个字节都放在不同的地方，只要你的C不是运行在某些性能极度孱弱，CPU结构高度简单的硬件上，【就算是在单片机上都做不到，所以许多单片机都会有“针对性优化”的需求，就是因为硬件和C源代码已经不再是简单的对应关系了】那么C的所谓“贴近硬件”其实和任何一种编译成机器指令的语言并没有本质差异……而包括你熟记的那套“内存字节对齐”这些概念，其实和硬件也没啥关系了

另一方面则是UNIX这个操作系统成功了啊……贝尔实验室本来想做的是一个又大又全面设计优雅的multics，结果调子起太高整个项目陷入严重问题，而unix这个系统相比起来，几乎就是个糊弄的脚本而已，包括unix的名字也是denis和ken开玩笑的谐音【因为功能太简陋所以干脆叫eunuches算了】来的

但是简陋，项目成功，商业成功，成为实际标准，**有上班经验的多半都听过“先跑起来最重要”，这个先跑起来的哲学在这里就表现出来了，设计优秀但是跑不起来的项目一文不值，但是如果通过背上技术债让程序能先跑起来，那技术债可以以后慢慢还（但是大多数时候，以后这个词对应的是遥遥无期了）**

自然就会有无数程序员需要基于C的abi和接口去开发程序，而1970到1990二十年，无数的程序开发出来，运行在各种硬件上，直接就变成事实标准了

事实标准导致的技术债和屎山当然难以撼动了

甚至直到今天，现代x86计算机的指令集已经无比复杂了，大量乱序执行/分支预测/向量化的时代，C都选择拒绝参与，而一直还在干“通过在x86计算机上模拟一台PDP-11”来干活

比如现代cpu主频已经上不去了，但是可以通过simd来提供并行化计算，结果C语义上不区分指针和数组，导致现代编译器在这块完全失灵无法优化，只能引入__restrict这样的标签来补漏，而__restrict只是个君子协定，并不是真正的约束（本质上约束力和注释没多大区别，你注释瞎写和代码实现无关，程序也不会编译不通过）

但是能怎么办呢，谁能想到那个年代只是个人糊弄出来用来写个4000行脚本的语言，今天居然成了人类信息化的基础

但是它本身已经在市场上成功了，这就意味着现代计算机的底层几乎全都绕不开这东西，无数工具链都是基于C的，大量人力物力投进去和C的各种特性斗争拼命并且源源不断产出成果，cpp也一直在尝试解决C这些问题，比如更优秀的标准库，引用，智能指针，试图消灭不安全的地方，然而cpp兼容c的语法永远会有人使用，一旦用了，那c的所有毛病都要被引入项目

然后呢？

你打算抛弃这一切重新来过么？那已经支付的沉没成本和技术债怎么办？

当然，另一面就是，市场成功，自然会有无数人来为你辩护，这个社会是赢者通吃的时代啊

比C还古老的fortran/cobol和后来的ada确实优雅安全啊，本来就是用在许多高性能而且高安全性的场合，比如航空航天，科学计算，许多跑fortran的硬件性能孱弱到C那套假装自己是PDP的路子根本跑不起来，并且由于语法约束严格，编译过程无歧义，可以从数学角度做极其激进的优化比如fortran就吃到了simd的红利

但是，这些语言都已经在自己的一亩三分地里出不去了呀，这个世界本来就是劣币驱逐良币的呀

今天大家都说“C什么都能干，但是对使用者要求高”这种话就是典型的“自有大儒为我辩经”

图灵完备的语言都是“什么都能干”，而C成功很大原因正是因为在1970年代，是对使用者要求更低的语言，同一时代的fortran，lisp等语言对使用者的要求更高，需要程序员真的又要懂数学又要懂计算机，确实一门语言“要求高”确实可以带来歧视链上的优越感，今天关于语言优越性的争吵中，很大一部分就是来自“我的语言要求高，所以我的能力水平比你厉害”。

然而……

**C恰恰是那个时代对程序员要求低的语言，而且时代也是这样的，对程序员要求越低的语言，越能拥有更多的使用者，学术派讲究语言的精巧严格，工程师很多时候是“能跑就行”，只是对于我们这些普通工程师，“能跑就行所以找个方便出活的语言”，而Ken这样的大牛选择的是“能跑就行所以自己糊个随便就能跑的语言”**

**只是今时今日，当那些上古的语言逐渐淡出人们的实现，年轻的程序员们眼里，C反而成了那个“更底层，对程序员要求更高”的那位了**

**而更讽刺的是，这种所谓的贴近底层都是一种缺乏对计算机过去几十年发展认知的程序员的自以为是，由于计算机硬件的复杂程度已经远超7080年代，今时今日2025年，如果你还觉得c是一种贴近硬件的语言，而你试图在一台x86或者arm机器上写c程序，那么多半只是因为简陋的前现代语法给你带来的错觉。**




**当然整个事情最好笑的地方在于——如果你觉得这些东西就应该程序员自己解决，于是关闭C编译器的各种优化，全靠C代码直出汇编——那么99%的“C语言大佬”写出来的代码性能甚至不如go**
